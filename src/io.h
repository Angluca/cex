#pragma once
#include "all.h"

/// Makes string literal with ansi colored test
#define io$ansi(text, ansi_col) "\033[" ansi_col "m" text "\033[0m"

/**
Cross-platform IO namespace

- Read all file content (low level api)
```c

test$case(test_readall)
{
    // Open new file
    FILE* file;
    e$ret(io.fopen(&file, "tests/data/text_file_50b.txt", "r"));


    // get file size 
    tassert_eq(50, io.file.size(file));

    // Read all content
    str_s content;
    e$ret(io.fread_all(file, &content, mem$));
    mem$free(mem$, content.buf); // content.buf is allocated by mem$ !

    // Cleanup
    io.fclose(&file); // file will be set to NULL
    tassert(file == NULL);

    return EOK;
}

```

- File load/save (easy api)
```c

test$case(test_fload_save)
{
    tassert_eq(Error.ok, io.file.save("tests/data/text_file_write.txt", "Hello from CEX!\n"));
    char* content = io.file.load("tests/data/text_file_write.txt", mem$);
    tassert(content);
    tassert_eq(content, "Hello from CEX!\n");
    mem$free(mem$, content);
    return EOK;
}

```

- File read/write lines 

```c
test$case(test_write_line)
{
    FILE* file;
    tassert_eq(Error.ok, io.fopen(&file, "tests/data/text_file_write.txt", "w+"));

    str_s content;
    mem$scope(tmem$, _)
    {
        // Writing line by line
        tassert_eq(EOK, io.file.writeln(file, "hello"));
        tassert_eq(EOK, io.file.writeln(file, "world"));

        // Reading line by line
        io.rewind(file);

        // easy api - backed by temp allocator
        tassert_eq("hello", io.file.readln(file, _));

        // low-level api (using heap allocator, needs free!)
        tassert_er(EOK, io.fread_line(file, &content, mem$));
        tassert(str.slice.eq(content, str$s("world")));
        mem$free(mem$, content.buf);
    }

    io.fclose(&file);
    return EOK;
}
```

- File low-level write/read
```c

test$case(test_read_loop)
{
    FILE* file;
    tassert_eq(Error.ok, io.fopen(&file, "tests/data/text_file_50b.txt", "r+"));

    char buf[128] = {0};

    // Read bytes
    isize nread = 0;
    while((nread = io.fread(file, buf, 10))) {
        if (nread < 0) {
            // TODO: io.fread() error occured, you should handle it here
            // NOTE: you can use os.get_last_error() for Exception representation of io.fread() err
            break;
        }
        
        tassert_eq(nread, 10);
        buf[10] = '\0';
        io.printf("%s", buf);
    }

    // Write bytes
    char buf2[] = "foobar";
    tassert_ne(EOK, io.fwrite(file, buf2, arr$len(buf2)));

    io.fclose(&file);
    return EOK;
}

```

*/
struct __cex_namespace__io {
    // Autogenerated by CEX
    // clang-format off

    /// Closes file and set it to NULL.
    void            (*fclose)(FILE** file);
    /// Flush changes to file
    Exception       (*fflush)(FILE* file);
    /// Obtain file descriptor from FILE*
    int             (*fileno)(FILE* file);
    /// Opens new file: io.fopen(&file, "file.txt", "r+")
    Exception       (*fopen)(FILE** file, char* filename, char* mode);
    /// Prints formatted string to the file. Uses CEX printf() engine with special formatting.
    Exc             (*fprintf)(FILE* stream, char* format,...);
    /// Read file contents into the buf, return nbytes read (can be < buff_len), 0 on EOF, negative on
    /// error (you may use os.get_last_error() for getting Exception for error, cross-platform )
    isize           (*fread)(FILE* file, void* buff, usize buff_len);
    /// Read all contents of the file, using allocator. You should free `s.buf` after.
    Exception       (*fread_all)(FILE* file, str_s* s, IAllocator allc);
    /// Reads line from a file into str_s buffer, allocates memory. You should free `s.buf` after.
    Exception       (*fread_line)(FILE* file, str_s* s, IAllocator allc);
    /// Seek file position
    Exception       (*fseek)(FILE* file, long offset, int whence);
    /// Returns current cursor position into `size` pointer
    Exception       (*ftell)(FILE* file, usize* size);
    /// Writes bytes to the file
    Exception       (*fwrite)(FILE* file, void* buff, usize buff_len);
    /// Check if current file supports ANSI colors and in interactive terminal mode
    bool            (*isatty)(FILE* file);
    /// Prints formatted string to stdout. Uses CEX printf() engine with special formatting.
    int             (*printf)(char* format,...);
    /// Rewind file cursor at the beginning
    void            (*rewind)(FILE* file);

    struct {
        /// Load full contents of the file at `path`, using text mode. Returns NULL on error.
        char*           (*load)(char* path, IAllocator allc);
        /// Reads line from file, allocates result. Returns NULL on error.
        char*           (*readln)(FILE* file, IAllocator allc);
        /// Saves full `contents` in the file at `path`, using text mode.
        Exception       (*save)(char* path, char* contents);
        /// Return full file size, always 0 for NULL file or atty
        usize           (*size)(FILE* file);
        /// Writes new line to the file
        Exception       (*writeln)(FILE* file, char* line);
    } file;

    // clang-format on
};
CEX_NAMESPACE struct __cex_namespace__io io;

