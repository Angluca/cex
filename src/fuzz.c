#if !defined(cex$enable_minimal)

#include "fuzz.h"

/// Creates new fuzz data generator, for fuzz-driven randomization
cex_fuzz_s
cex_fuzz_create(const u8* data, usize size)
{
    return (cex_fuzz_s){
        .cur = data,
        .end = data + size,
    };
}

/// Get result from random data into buffer (returns false if not enough data)
bool
cex_fuzz_dget(cex_fuzz_s* fz, void* out_result, usize result_size)
{
    uassert(out_result != NULL);
    if (fz->end - fz->cur < (isize)result_size) { return false; }
    memcpy(out_result, fz->cur, result_size);
    fz->cur += result_size;
    return true;
}

/// Get current corpus dir relative tho the `this_file_name`
char*
cex_fuzz_corpus_dir(char* this_file_name)
{
    static char buf[256] = {0};

    if (buf[0] != '\0') {
        // already filled 
        return buf;
    }

    uassert(this_file_name);
    uassert(this_file_name[0] != '\0');
    uassert(str.len(this_file_name) < sizeof(buf)-1);
    uassert(str.ends_with(this_file_name, ".c"));
    if(str.sprintf(buf, sizeof(buf), "%S_corpus", str.sub(this_file_name, 0, -2))) {
        return NULL;
    }

    return buf;
}

/// Get probability using fuzz data, based on threshold
bool
cex_fuzz_dprob(cex_fuzz_s* fz, double threshold)
{
    uassert(
        threshold > 0 && threshold < 1.0 &&
        "Probability must be > 0 and < 1.0, 0.1 = 10% probability"
    );
    uassert(threshold > 1.0 / 255.0 && "Probability granularity is too low");
    if (fz->cur >= fz->end) { return false; }

    double p = (double)fz->cur[0];
    fz->cur++;

    return (p / 255.0) <= threshold;
}

const struct __cex_namespace__fuzz fuzz = {
    // Autogenerated by CEX
    // clang-format off

    .corpus_dir = cex_fuzz_corpus_dir,
    .create = cex_fuzz_create,
    .dget = cex_fuzz_dget,
    .dprob = cex_fuzz_dprob,

    // clang-format on
};

#endif
