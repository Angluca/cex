/**
 * @file
 * @brief
 */

#pragma once
#include "all.h"

/// Represents char* slice (string view) + may not be null-term at len!
typedef struct
{
    usize len;
    char* buf;
} str_s;

_Static_assert(alignof(str_s) == alignof(usize), "align");
_Static_assert(sizeof(str_s) == sizeof(usize) * 2, "size");


/**
 * @brief creates str_s, instance from string literals/constants: str$s("my string")
 *
 * Uses compile time string length calculation, only literals
 *
 */
#define str$s(string)                                                                              \
    (str_s){ .buf = /* WARNING: only literals!!!*/ "" string, .len = sizeof((string)) - 1 }


/**
 * @brief creates slice of str_s instance
 */
#define str$sslice(str_self, ...)                                                                  \
    ({                                                                                             \
        slice$define(*(str_self.buf)) __slice = { .arr = NULL, .len = 0 };                         \
        _arr$slice_get(__slice, str_self.buf, str_self.len, __VA_ARGS__);                          \
        __slice;                                                                                   \
    })

#define str$join(allocator, str_join_by, str_parts...)                                             \
    ({                                                                                             \
        const char* _args[] = { str_parts };                                                       \
        usize _args_len = arr$len(_args);                                                          \
        str.join(_args, _args_len, str_join_by, allocator);                                        \
    })

/// Parses string contents as value type based on generic numeric type of out_var_ptr 
#define str$convert(str_or_slice, out_var_ptr)                                                     \
    _Generic((str_or_slice), \
    char*: _Generic((out_var_ptr), \
        i8*:  str.convert.to_i8, \
        u8*:  str.convert.to_u8, \
        i16*:  str.convert.to_i16, \
        u16*:  str.convert.to_u16, \
        i32*:  str.convert.to_i32, \
        u32*:  str.convert.to_u32, \
        i64*:  str.convert.to_i64, \
        u64*:  str.convert.to_u64, \
        f32*:  str.convert.to_f32, \
        f64*:  str.convert.to_f64 \
    ), \
    str_s: _Generic((out_var_ptr), \
        i8*:  str.convert.to_i8s, \
        u8*:  str.convert.to_u8s, \
        i16*:  str.convert.to_i16s, \
        u16*:  str.convert.to_u16s, \
        i32*:  str.convert.to_i32s, \
        u32*:  str.convert.to_u32s, \
        i64*:  str.convert.to_i64s, \
        u64*:  str.convert.to_u64s, \
        f32*:  str.convert.to_f32s, \
        f64*:  str.convert.to_f64s \
    ) \
)(str_or_slice, out_var_ptr)

struct __cex_namespace__str
{
    // Autogenerated by CEX
    // clang-format off

    char*           (*clone)(const char* s, IAllocator allc);
    Exception       (*copy)(char* dest, const char* src, usize destlen);
    bool            (*ends_with)(const char* str, const char* suffix);
    bool            (*eq)(const char* a, const char* b);
    bool            (*eqi)(const char* a, const char* b);
    char*           (*find)(const char* haystack, const char* needle);
    char*           (*findr)(const char* haystack, const char* needle);
    char*           (*fmt)(IAllocator allc, const char* format,...);
    char*           (*join)(const char** str_arr, usize str_arr_len, const char* join_by, IAllocator allc);
    usize           (*len)(const char* s);
    char*           (*lower)(const char* s, IAllocator allc);
    bool            (*match)(const char* s, const char* pattern);
    int             (*qscmp)(const void* a, const void* b);
    int             (*qscmpi)(const void* a, const void* b);
    char*           (*replace)(const char* str, const char* old_sub, const char* new_sub, IAllocator allc);
    str_s           (*sbuf)(char* s, usize length);
    arr$(char*)     (*split)(const char* s, const char* split_by, IAllocator allc);
    arr$(char*)     (*split_lines)(const char* s, IAllocator allc);
    Exc             (*sprintf)(char* dest, usize dest_len, const char* format,...);
    /// Creates string slice of input c-str (NULL tolerant, (str_s){0} on error)
    str_s           (*sstr)(const char* ccharptr);
    bool            (*starts_with)(const char* str, const char* prefix);
    str_s           (*sub)(const char* s, isize start, isize end);
    char*           (*upper)(const char* s, IAllocator allc);
    Exception       (*vsprintf)(char* dest, usize dest_len, const char* format, va_list va);

    struct {
        Exception       (*to_f32)(const char* s, f32* num);
        Exception       (*to_f32s)(str_s s, f32* num);
        Exception       (*to_f64)(const char* s, f64* num);
        Exception       (*to_f64s)(str_s s, f64* num);
        Exception       (*to_i16)(const char* s, i16* num);
        Exception       (*to_i16s)(str_s s, i16* num);
        Exception       (*to_i32)(const char* s, i32* num);
        Exception       (*to_i32s)(str_s s, i32* num);
        Exception       (*to_i64)(const char* s, i64* num);
        Exception       (*to_i64s)(str_s s, i64* num);
        Exception       (*to_i8)(const char* s, i8* num);
        Exception       (*to_i8s)(str_s s, i8* num);
        Exception       (*to_u16)(const char* s, u16* num);
        Exception       (*to_u16s)(str_s s, u16* num);
        Exception       (*to_u32)(const char* s, u32* num);
        Exception       (*to_u32s)(str_s s, u32* num);
        Exception       (*to_u64)(const char* s, u64* num);
        Exception       (*to_u64s)(str_s s, u64* num);
        Exception       (*to_u8)(const char* s, u8* num);
        Exception       (*to_u8s)(str_s s, u8* num);
    } convert;

    struct {
        char*           (*clone)(str_s s, IAllocator allc);
        Exception       (*copy)(char* dest, str_s src, usize destlen);
        bool            (*ends_with)(str_s s, str_s suffix);
        bool            (*eq)(str_s a, str_s b);
        bool            (*eqi)(str_s a, str_s b);
        isize           (*index_of)(str_s str, str_s needle);
        str_s           (*iter_split)(str_s s, const char* split_by, cex_iterator_s* iterator);
        str_s           (*lstrip)(str_s s);
        bool            (*match)(str_s s, const char* pattern);
        int             (*qscmp)(const void* a, const void* b);
        int             (*qscmpi)(const void* a, const void* b);
        str_s           (*remove_prefix)(str_s s, str_s prefix);
        str_s           (*remove_suffix)(str_s s, str_s suffix);
        str_s           (*rstrip)(str_s s);
        bool            (*starts_with)(str_s str, str_s prefix);
        str_s           (*strip)(str_s s);
        str_s           (*sub)(str_s s, isize start, isize end);
    } slice;

    // clang-format on
};
__attribute__((visibility("hidden"))) extern const struct __cex_namespace__str str;
