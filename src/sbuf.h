#pragma once
#include "all.h"
#include <assert.h>

typedef char* sbuf_c;

typedef struct
{
    struct
    {
        u32 magic : 16;   // used for sanity checks
        u32 elsize : 8;   // maybe multibyte strings in the future?
        u32 nullterm : 8; // always zero to prevent usage of direct buffer
    } header;
    Exc err;
    const Allocator_i* allocator;
    usize capacity;
    usize length;
} __attribute__((packed)) sbuf_head_s;

static_assert(alignof(sbuf_head_s) == 1, "align");
static_assert(alignof(sbuf_head_s) == alignof(char), "align");
//static_assert(sizeof(sbuf_head_s) == 36, "size");

/**

Dynamic string builder class

Key features:

- Dynamically grown strings 
- Supports CEX specific formats 
- Can be backed by allocator or static buffer
- Error resilient

*/
struct __cex_namespace__sbuf {
    // Autogenerated by CEX
    // clang-format off

    Exc             (*append)(sbuf_c* self, char* s);
    Exc             (*appendf)(sbuf_c* self, char* format,...);
    Exc             (*appendfva)(sbuf_c* self, char* format, va_list va);
    u32             (*capacity)(sbuf_c* self);
    void            (*clear)(sbuf_c* self);
    sbuf_c          (*create)(u32 capacity, IAllocator allocator);
    sbuf_c          (*create_static)(char* buf, usize buf_size);
    sbuf_c          (*create_temp)(void);
    sbuf_c          (*destroy)(sbuf_c* self);
    Exception       (*grow)(sbuf_c* self, usize new_capacity);
    bool            (*isvalid)(sbuf_c* self);
    u32             (*len)(sbuf_c* self);
    void            (*shrink)(sbuf_c* self, usize new_length);
    void            (*update_len)(sbuf_c* self);
    Exception       (*validate)(sbuf_c* self);

    // clang-format on
};
CEX_NAMESPACE struct __cex_namespace__sbuf sbuf;

