#pragma once
#include "all.h"
#include <assert.h>

typedef char* sbuf_c;

typedef struct
{
    struct
    {
        u32 magic : 16;   // used for sanity checks
        u32 elsize : 8;   // maybe multibyte strings in the future?
        u32 nullterm : 8; // always zero to prevent usage of direct buffer
    } header;
    Exc err;
    const Allocator_i* allocator;
    usize capacity;
    usize length;
} __attribute__((packed)) sbuf_head_s;

static_assert(alignof(sbuf_head_s) == 1, "align");
static_assert(alignof(sbuf_head_s) == alignof(char), "align");
//static_assert(sizeof(sbuf_head_s) == 36, "size");
/**

Dynamic string builder class

Key features:

- Dynamically grown strings 
- Supports CEX specific formats 
- Can be backed by allocator or static buffer
- Error resilient - allows self as NULL
- `sbuf_c` - is an alias of `char*`, always null terminated, compatible with any C strings 

- Allocator driven dynamic string
```c
sbuf_c s = sbuf.create(20, mem$);

// These may fail (you may use them with e$* checks or add final check)
sbuf.appendf(&s, "%s, CEX slice: %S\n", "456", str$s("slice"));
sbuf.append(&s, "some string");

e$except(err, sbuf.validate(&s)) {
    // Error handling
}

if (!sbuf.isvalid(&s)) {
    // Error, just a boolean flag
}

// Some other stuff
strlen(s); // C strings work, because sbuf_c is vanilla char*
sbuf.len(&s); // faster way of getting length (uses metadata)
sbuf.grow(&s, new_capacity); // increase capacity
sbuf.capacity(&s); // current capacity, 0 if error occurred
sbuf.clear(&s); // reset dynamic string + null term



// Frees the memory and sets s to NULL
sbuf.destroy(&s);
```

- Static buffer backed string
```c

// NOTE: `s` address is different, because `buf` will contain header and metadata, use only `s`
char buf[64];
sbuf_c s = sbuf.create_static(buf, arr$len(buf));

// You may check every operation if needed, but this more verbose
e$ret(sbuf.appendf(&s, "%s, CEX slice: %S\n", "456", str$s("slice")));
e$ret(sbuf.append(&s, "some string"));

// It's not mandatory, but will clean up buffer data at the end
sbuf.destroy(&s);
```

*/
struct __cex_namespace__sbuf {
    // Autogenerated by CEX
    // clang-format off

    Exc             (*append)(sbuf_c* self, char* s);
    Exc             (*appendf)(sbuf_c* self, char* format,...);
    Exc             (*appendfva)(sbuf_c* self, char* format, va_list va);
    u32             (*capacity)(sbuf_c* self);
    void            (*clear)(sbuf_c* self);
    /// Creates new dynamic string builder backed by allocator
    sbuf_c          (*create)(usize capacity, IAllocator allocator);
    sbuf_c          (*create_static)(char* buf, usize buf_size);
    sbuf_c          (*create_temp)(void);
    sbuf_c          (*destroy)(sbuf_c* self);
    Exception       (*grow)(sbuf_c* self, usize new_capacity);
    bool            (*isvalid)(sbuf_c* self);
    u32             (*len)(sbuf_c* self);
    void            (*shrink)(sbuf_c* self, usize new_length);
    void            (*update_len)(sbuf_c* self);
    Exception       (*validate)(sbuf_c* self);

    // clang-format on
};
CEX_NAMESPACE struct __cex_namespace__sbuf sbuf;

