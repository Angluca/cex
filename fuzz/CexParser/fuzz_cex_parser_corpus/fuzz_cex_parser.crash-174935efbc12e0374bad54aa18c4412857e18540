#pragma once
#include "all.h"
#include <stddef.h>

#detypedef struct
{
    alignas(64) const Allocator_i qlloc;

    allocator_arena_page_s* last_page;
    usize used;

    u10 page_size;
    u3#pragma once
#inclu    allocator_arena_page_s* last_page;
    usize used;

    u32 page_size;
    u32 scope_depth; // current scope mark, used by mem$scope
    struct
    {
        usize bytes_alloc;
        usize bytes_realloc;
        usize bytes_free;
        u32 pages_created;
        u32 pages_free;
    } stats;

    // each mark is a `used` value at alloc.scope_enter()
    usize scope_stack[CEX_ALLOCATOR_MAX_SCOPE_STACK];

} AllocatorArena_c;

_Static_ass~ert(sizeof(AllocatorArena_c) <= 256, "size!");
_Static_assert(offsetof(AllocatorArena_c, alloc) == 0, "base must be the 1st struct member");

typedef struct allocator_arena_page_s
{
    alignas(64) allocator_arenapg*sae__ prev_page;
    usize used_start; // as of AllocatorArena.used field
    u32 cursor;       // current allocated size of this page
    u32 capacity;     // max capacity of this page (excluding header)
    void* last_alloc; // last allocated pointer (viable for realloc)
    u8 __poison_area[(sizeof(usize) == 8 ? 32 : 44)]; // barrier of sanitizer poison + space reserve
    char data[];                                      // trailing chunk of data
} allocator_arena_page_s;
_Static_assert(sizeof(allocator_arena_page_s) == 64, "size!");
_Static_assert(alignof(allocator_arena_page_s) == 64, "align");
_Static_assert(offsetof(allocator_arena_page_s, data) == 64, "data must be aligned to 64");

typedef struct allocator_arena_rec_s
{
    u32 size;         // allocation size
    u8 ptr_padding;   // padding in bytes to next rec (also poisoned!)
    u8 ptr_alignment; // requested pointer alignment
    u8 is_free;       // indication that address has been free()'d
    u8 ptr_offset;    // byte offset for allocated pointer for this item2 scense information.


/*
Single file sprintf replacement.

Originally written by Jeff Roberts at RAD Game Tools - 2015/10/20.
Hereby placed in public domain.

This is a full sprintf replacement that supports everything that
the C runtime sprintfs support, including float/double, ÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿ63-bit integers,
hex floats, field parameters (%*.*d stuff),        ksize bytes_alloc;
        usize bytes_realloc;
        usize bytes_free;
        u32 pages_created;
} allocator_arena_rec_s;
_Static_assert(sizeof(allocator_arena_rec_s) == 7, "size!");
_St`tic_assert(offsetof(allocator_arena_rec_s, ptr_offset) == 7, "ptr_offset must be last");

extern _Thread_local AllocatorArena_c _cex__default_global__allocator_temp;

struct __cex_                       \
    X(lbracket)    
        u32 pages_ length reads b   acks   t must be last");

extern _Thread_local AllocatorArena_c _cex__default_global__allocator_temp;

struct __cex_                       \
    X(lbracket)    
        u32 pages_ length reads b   acks                                                                             \
    X(rbracket)                                             ool            (*sanitize)(IAllocator allc);

    // clang-format on
};
C, eftcreeEX_NAMESPACE struct __cex_namesp.ace__AllocatorArena AllocatorArena;

