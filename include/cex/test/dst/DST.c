#pragma once
#include "DST.h"
#include "cex/cex.h"
#include <stdatomic.h>

DST_c _DST = { 0 };

Exception
DST_create(u64 seed)
{
    e$assert(seed > 0);
    e$assert(atomic_is_lock_free(&_DST._lock) && "Atomic is not lock free/not supported!");
    e$assertf(
        !atomic_flag_test_and_set(&_DST._lock),
        "Already in use OR access from different thread OR DST.create() called before DST.destroy()"
    );
    e$assert(
        !atomic_flag_test_and_set(&_DST._lock_rng) &&
        "Already in use or access from different thread or uninitialized DSTState"
    );
    e$assert(_DST._initial_seed == 0 && "expected uninitialized");

    memset(&_DST, 0, sizeof(_DST));

    Random.seed(&_DST._rng, _DST._initial_seed);
    _DST._initial_seed = seed;
    _DST._initial_time = time(NULL);

    atomic_flag_test_and_set(&_DST._lock);
    atomic_flag_clear(&_DST._lock_rng);

    return EOK;
}

Exception
DST_setup(dst_params_s* prm)
{
    uassert(prm != NULL);
    e$assert(prm->allocators.malloc_fail_prob >= 0 && prm->allocators.malloc_fail_prob <= 1);
    e$assert(_DST._initial_seed > 0);

    memcpy(&_DST.prm, prm, sizeof(dst_params_s));

    return EOK;
}

bool
DST_rnd_check(f32 prob_threshold)
{
    // DST is designed to be used only single threaded! Assert this.
    uassert(!atomic_flag_test_and_set(&_DST._lock_rng) && "already locked, using multi-threading?");

    bool result = Random.prob(&_DST._rng, prob_threshold);

    atomic_flag_clear(&_DST._lock_rng);
    return result;
}

f32
DST_rnd_prob()
{
    // DST is designed to be used only single threaded! Assert this.
    uassert(!atomic_flag_test_and_set(&_DST._lock_rng) && "already locked, using multi-threading?");

    f32 result = Random.f32(&_DST._rng);

    atomic_flag_clear(&_DST._lock_rng);
    return result > 0.05f ? result : 0.05f;
}

usize
DST_rnd_range(usize min, usize max)
{
    // DST is designed to be used only single threaded! Assert this.
    uassert(!atomic_flag_test_and_set(&_DST._lock_rng) && "already locked, using multi-threading?");

    usize result = Random.range(&_DST._rng, min, max);

    atomic_flag_clear(&_DST._lock_rng);
    return result;
}

void DST_print_state(){
    // WARNING: don't use uassert() here, because this will cause infinite recursion on failure!
    printf("DST:\n");
    printf("\tseed: %lu\n", _DST._initial_seed);
    printf("\ttime elapsed: %lu sec\n", time(NULL) - _DST._initial_time);
    printf("\tRandom state:\n");
    printf("\t\tstate[0]: %lu\n", _DST._rng.state[0]);
    printf("\t\tstate[1]: %lu\n", _DST._rng.state[1]);
    printf("\t\tn_ticks: %lu\n", _DST._rng.n_ticks);
}

void
DST_destroy()
{
    _DST._initial_seed = 0;
    atomic_flag_clear(&_DST._lock_rng);
    atomic_flag_clear(&_DST._lock);
}

const struct __class__DST DST = {
    // Autogenerated by CEX
    // clang-format off
    .create = DST_create,
    .setup = DST_setup,
    .rnd_check = DST_rnd_check,
    .rnd_prob = DST_rnd_prob,
    .rnd_range = DST_rnd_range,
    .print_state = DST_print_state,
    .destroy = DST_destroy,
    // clang-format on
};
