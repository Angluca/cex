

Cross-platform OS related operations:

- `os.cmd.` - for running commands and interacting with them
- `os.fs.` - file-system related tasks
- `os.env.` - getting setting environment variable
- `os.path.` - file path operations
- `os.platform.` - information about current platform


Examples:

- Running simple commands
```c
// NOTE: there are many operation with os-related stuff in cexy build system
// try to play in example roulette:  ./cex help --example os.cmd.run

// Easy macro, run fixed number of arguments

e$ret(os$cmd(
    cexy$cc,
    "src/main.c",
    cexy$build_dir "/sqlite3.o",
    cexy$cc_include,
    "-lpthread",
    "-lm",
    "-o",
    cexy$build_dir "/hello_sqlite"
));


```

- Running dynamic arguments
```c
mem$scope(tmem$, _)
{
        arr$(char*) args = arr$new(args, _);
        arr$pushm(
            args,
            cexy$cc,
            "-Wall",
            "-Werror",
        );

        if (os.platform.current() == OSPlatform__win) {
            arr$pushm(args, "-lbcrypt");
        }

        arr$pushm(args, NULL); // NOTE: last element must be NULL
        e$ret(os$cmda(args));
    }
}
```

- Getting command output (low level api)
```c

test$case(os_cmd_create)
{
    os_cmd_c c = { 0 };
    mem$scope(tmem$, _)
    {
        char* args[] = { "./cex", NULL };
        tassert_er(EOK, os.cmd.create(&c, args, arr$len(args), NULL));

        char* output = os.cmd.read_all(&c, _);
        tassert(output != NULL);
        io.printf("%s\n", output);

        int err_code = 0;
        tassert_er(Error.runtime, os.cmd.join(&c, 0, &err_code));
        tassert_eq(err_code, 1);
    }
    return EOK;
}
```

- Working with files
```c

test$case(test_os_find_all_c_files)
{
    mem$scope(tmem$, _)
    {
        // Check if exists and remove
        if (os.path.exists("./cex")) { e$ret(os.fs.remove("./cex")); }

        // illustration of path combining
        char* pattern = os$path_join(_, "./", "*.c");

        // find all matching *.c files
        for$each (it, os.fs.find(pattern, _), false , _)) {
            log$debug("found file: %s\n", it);
        }
    }

    return EOK;
}
```




```c
/// OS path separator, generally '\' for Windows, '/' otherwise
#define os$PATH_SEP

/// Run command by arbitrary set of arguments (returns Exc, but error check is not mandatory). Pipes
/// all IO to stdout/err/in into current terminal, feels totally interactive. 
/// Example: e$ret(os$cmd("cat", "./cex.c"))
#define os$cmd(args...)

/// Run command by dynamic or static array (returns Exc, but error check is not mandatory). Pipes
/// all IO to stdout/err/in into current terminal, feels totally interactive.
#define os$cmda(args, args_len...)

/// Path parts join by variable set of args: os$path_join(mem$, "foo", "bar", "cex.c")
#define os$path_join(allocator, path_parts...)

/// Command container (current state of subprocess)
typedef os_cmd_c

/// Additional flags for os.cmd.create()
typedef os_cmd_flags_s

/// File stats metadata (cross-platform), returned by os.fs.stats
typedef os_fs_stat_s



os {
    // Autogenerated by CEX
    // clang-format off

    /// Get last system API error as string representation (Exception compatible). Result content may be
    /// affected by OS locale settings.
    Exc             (*get_last_error)(void);
    /// Sleep for `period_millisec` duration
    void            (*sleep)(u32 period_millisec);
    /// Get high performance monotonic timer value in seconds
    f64             (*timer)(void);

    struct {
        /// Creates new os command (use os$cmd() and os$cmd() for easy cases)
        Exception       (*create)(os_cmd_c* self, char** args, usize args_len, os_cmd_flags_s* flags);
        /// Check if `cmd_exe` program name exists in PATH. cmd_exe can be absolute, or simple command name,
        /// e.g. `cat`
        bool            (*exists)(char* cmd_exe);
        /// Get running command stderr stream
        FILE*           (*fstderr)(os_cmd_c* self);
        /// Get running command stdin stream
        FILE*           (*fstdin)(os_cmd_c* self);
        /// Get running command stdout stream
        FILE*           (*fstdout)(os_cmd_c* self);
        /// Checks if process is running
        bool            (*is_alive)(os_cmd_c* self);
        /// Waits process to end, and get `out_ret_code`, if timeout_sec=0 - infinite wait, raises
        /// Error.runtime if out_ret_code != 0
        Exception       (*join)(os_cmd_c* self, u32 timeout_sec, i32* out_ret_code);
        /// Terminates the running process
        Exception       (*kill)(os_cmd_c* self);
        /// Read all output from process stdout, NULL if stdout is not available
        char*           (*read_all)(os_cmd_c* self, IAllocator allc);
        /// Read line from process stdout, NULL if stdout is not available
        char*           (*read_line)(os_cmd_c* self, IAllocator allc);
        /// Run command using arguments array and resulting os_cmd_c
        Exception       (*run)(char** args, usize args_len, os_cmd_c* out_cmd);
        /// Writes line to the process stdin
        Exception       (*write_line)(os_cmd_c* self, char* line);
    } cmd;

    struct {
        /// Get environment variable, with `deflt` if not found
        char*           (*get)(char* name, char* deflt);
        /// Set environment variable
        Exception       (*set)(char* name, char* value);
    } env;

    struct {
        /// Change current working directory
        Exception       (*chdir)(char* path);
        /// Copy file
        Exception       (*copy)(char* src_path, char* dst_path);
        /// Copy directory recursively
        Exception       (*copy_tree)(char* src_dir, char* dst_dir);
        /// Iterates over directory (can be recursive) using callback function
        Exception       (*dir_walk)(char* path, bool is_recursive, os_fs_dir_walk_f callback_fn, void* user_ctx);
        /// Finds files in `dir/pattern`, for example "./mydir/*.c" (all c files), if is_recursive=true, all
        /// *.c files found in sub-directories.
        arr$(char*)     (*find)(char* path_pattern, bool is_recursive, IAllocator allc);
        /// Get current working directory
        char*           (*getcwd)(IAllocator allc);
        /// Makes directory (no error if exists)
        Exception       (*mkdir)(char* path);
        /// Makes all directories in a path
        Exception       (*mkpath)(char* path);
        /// Removes file or empty directory (also see os.fs.remove_tree)
        Exception       (*remove)(char* path);
        /// Removes directory and all its contents recursively
        Exception       (*remove_tree)(char* path);
        /// Renames file or directory
        Exception       (*rename)(char* old_path, char* new_path);
        /// Returns cross-platform path stats information (see os_fs_stat_s)
        os_fs_stat_s    (*stat)(char* path);
    } fs;

    struct {
        /// Returns absolute path from relative
        char*           (*abs)(char* path, IAllocator allc);
        /// Get file name of a path
        char*           (*basename)(char* path, IAllocator allc);
        /// Get directory name of a path
        char*           (*dirname)(char* path, IAllocator allc);
        /// Check if file/directory path exists
        bool            (*exists)(char* file_path);
        /// Join path with OS specific path separator
        char*           (*join)(char** parts, u32 parts_len, IAllocator allc);
        /// Splits path by `dir` and `file` parts, when return_dir=true - returns `dir` part, otherwise
        /// `file` part
        str_s           (*split)(char* path, bool return_dir);
    } path;

    struct {
        /// Returns OSArch from string
        OSArch_e        (*arch_from_str)(char* name);
        /// Converts arch to string
        char*           (*arch_to_str)(OSArch_e platform);
        /// Returns current OS platform, returns enum of OSPlatform__*, e.g. OSPlatform__win,
        /// OSPlatform__linux, OSPlatform__macos, etc..
        OSPlatform_e    (*current)(void);
        /// Returns string name of current platform
        char*           (*current_str)(void);
        /// Converts platform name to enum
        OSPlatform_e    (*from_str)(char* name);
        /// Converts platform enum to name
        char*           (*to_str)(OSPlatform_e platform);
    } platform;

    // clang-format on
};

```
