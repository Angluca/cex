Symbol found at ./cex.h:4071


- Fuzz runner commands

`./cex fuzz create fuzz/myapp/fuzz_bar.c`

`./cex fuzz run fuzz/myapp/fuzz_bar.c`

- Fuzz testing tools using `fuzz` namespace

```c

int
fuzz$case(const u8* data, usize size)
{
    cex_fuzz_s fz = fuzz.create(data, size);
    u16 random_val = 0;
    some_struct random_struct = {0}; 

    while(fuzz.dget(&fz, &random_val, sizeof(random_val))) {
        // testing function with random data
        my_func(random_val);

        // checking probability based on fuzz data
        if (fuzz.dprob(&fz, 0.2)) {
            my_func(random_val * 10);
        }

        if (fuzz.dget(&fz, &random_struct, sizeof(random_struct))){
            my_func_struct(&random_struct);
        }
    }
}

```
- Fuzz testing tools using `fuzz$` macros (shortcuts)

```c

int
fuzz$case(const u8* data, usize size)
{
    fuzz$dnew(data, size);

    u16 random_val = 0;
    some_struct random_struct = {0}; 

    while(fuzz$dget(&random_val)) {
        // testing function with random data
        my_func(random_val);

        // checking probability based on fuzz data
        if (fuzz$dprob(0.2)) {
            my_func(random_val * 10);
        }

        // it's possible to fill whole structs with data
        if (fuzz$dget(&random_struct)){
            my_func_struct(&random_struct);
        }
    }
}

```

- Fuzz corpus priming (it's optional step, but useful)

```c

typedef struct fuzz_match_s
{
    char pattern[100];
    char null_term;
    char text[300];
    char null_term2;
} fuzz_match_s;

Exception
match_make(char* out_file, char* text, char* pattern)
{
    fuzz_match_s f = { 0 };
    e$ret(str.copy(f.text, text, sizeof(f.text)));
    e$ret(str.copy(f.pattern, pattern, sizeof(f.pattern)));

    FILE* fh;
    e$ret(io.fopen(&fh, out_file, "wb"));
    e$ret(io.fwrite(fh, &f, sizeof(f), 1));
    io.fclose(&fh);

    return EOK;
}

fuzz$setup()
{
    if (os.fs.mkdir(fuzz$corpus_dir)) {}

    struct
    {
        char* text;
        char* pattern;
    } match_tuple[] = {
        { "test", "*" },
        { "", "*" },
        { ".txt", "*.txt" },
        { "test.txt", "" },
        { "test.txt", "*txt" },
    };
    mem$scope(tmem$, _)
    {
        for (u32 i = 0; i < arr$len(match_tuple); i++) {
            char* fn = str.fmt(_, "%s/%05d", fuzz$corpus_dir, i);
            e$except (err, match_make(fn, match_tuple[i].text, match_tuple[i].pattern)) {
                uassertf(false, "Error writing file: %s", fn);
            }
        }
    }
}

```



```c
/// Fuzz case: ``int fuzz$case(const u8* data, usize size) { return 0;}
#define fuzz$case

/// Current fuzz_ file corpus directory relative to calling source file
#define fuzz$corpus_dir

/// Load random data into variable by pointer from random fuzz data
#define fuzz$dget(out_result_ptr)

/// Initialize fuzz$ helper macros
#define fuzz$dnew(data, size)

/// Get deterministic probability based on fuzz data
#define fuzz$dprob(prob_threshold)

/// Special fuzz variable used by all fuzz$ macros
#define fuzz$dvar

/// Fuzz main function
#define fuzz$main()

/// Fuzz test constructor (for building corpus seeds programmatically)
#define fuzz$setup



fuzz {
    // Autogenerated by CEX
    // clang-format off

    /// Get current corpus dir relative tho the `this_file_name`
    char*           (*corpus_dir)(char* this_file_name);
    /// Creates new fuzz data generator, for fuzz-driven randomization
    cex_fuzz_s      (*create)(const u8* data, usize size);
    /// Get result from random data into buffer (returns false if not enough data)
    bool            (*dget)(cex_fuzz_s* fz, void* out_result, usize result_size);
    /// Get deterministic probability using fuzz data, based on threshold
    bool            (*dprob)(cex_fuzz_s* fz, double threshold);

    // clang-format on
};

```
