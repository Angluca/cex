Symbol found at ./cex.h:3634


Low level JSON reader/writer namespace

Making own JSON buffer:

```c
jw_c jb;
e$ret(json.buf.create(&jb, 1024, 0, mem$));
json$buf(&jb, JsonType__obj)
{
    json$kstr("foo2", "%d", 1);
    json$kobj("foo3") {
        json$kval("bar", "%s", "3");
    }
    json$karr("foo3") {
        json$val("%d", 8);
        json$str("%d", 9);
    }
}
>> json.buf.get(&jb) ->
>> {"foo2": "1", "foo3": {"bar": 3},"foo3": [8, "9"]}


Reading JSON buffer:
```c
    struct Foo
    {
        struct { u32 baz; u32 fuzz; } foo;
        u32 next;
        u32 baz;
    } data = { 0 };
    str_s content = str$s(
        "{ \"foo\" : {\"baz\": 3, \"fuzz\": 8, \"oops\": 0}, \"next\": 7, \"baz\": 17 }"
    );
    jr_c js;
    e$ret(json.reader.create(&js, content.buf, 0, false));
    if (json.reader.next(&js)) { e$ret(json.reader.step_in(&js, JsonType__obj)); }
    while (json.reader.next(&js)) {
        json$key_invalid (&js) {}
        json$key_match (&js, "foo") {
            e$ret(json.reader.step_in(&js, JsonType__obj));
            while (json.reader.next(&js)) {
                json$key_invalid (&js) {}
                json$key_match (&js, "fuzz") { e$ret(str$convert(js.val, &data.foo.fuzz)); }
                json$key_match (&js, "baz") { e$ret(str$convert(js.val, &data.foo.baz)); }
                json$key_unmatched(&js)
                {
                    tassert_eq(js.key, str$s("oops"));
                }
            }
        }
        json$key_match (&js, "next") { e$ret(str$convert(js.val, &data.next)); }
        json$key_match (&js, "baz") { e$ret(str$convert(js.val, &data.baz)); }
    }
    e$assert(js.error == EOK && "No parsing errors");

```



```c
/// Add new [...] scope into (json$buf)
#define json$arr()

/// Opens JSON buffer scope (json_writer_ptr data is cleared out)
#define json$buf(json_writer_ptr, jsontype_arr_or_obj)

/// Append any formatted string, it's for low level printing (json$buf)
#define json$fmt(format, ...)

/// Add new key: [...] scope into (json$buf)
#define json$karr(key)

/// Beginning of json$key_match chain (always first, checks if key is NULL)
#define json$key_invalid(json_reader)

/// Matches object key by key literal name (compile time optimized string compare)
#define json$key_match(json_reader, key_literal)

/// Checks if there is unexpected key
#define json$key_unmatched(json_reader)

/// Add new key: {...} scope into (json$buf)
#define json$kobj(key)

/// Append `"<key>": "<format>"` (with your own format) into object scope (json$buf)
#define json$kstr(key, format, ...)

/// Append `"<key>": <format>` into object scope (json$buf)
#define json$kval(key, format, ...)

/// Add new {...} scope into (json$buf)
#define json$obj()

/// Append string item into array scope (json$buf)
#define json$str(format, ...)

/// Append value item into array scope (json$buf)
#define json$val(format, ...)

typedef jw_c

typedef jr_c



json {
    // Autogenerated by CEX
    // clang-format off


    struct {
        /// Create JSON buffer/builder container used with json$buf / json$fmt / json$kstr macros
        Exception       (*create)(jw_c* jb, u32 capacity, u8 indent, IAllocator allc);
        /// Destroy JSON buffer instance (not necessary to call if initialized on tmem$ allocator)
        void            (*destroy)(jw_c* jb);
        /// Get JSON buffer contents (NULL if any error occurred)
        char*           (*get)(jw_c* jb);
        /// Check if there is any error in JSON buffer
        Exception       (*validate)(jw_c* jb);
    } buf;

    struct {
        /// Create new JSON reader (it doesn't allocate memory and uses content slicing)
        Exception       (*create)(jr_c* it, char* content, usize content_len, bool strict_mode);
        /// Get next JSON item for a scope
        bool            (*next)(jr_c* it);
        /// Make step inside JSON object or array scope (json.reader.next() starts emitting this scope)
        Exception       (*step_in)(jr_c* it, JsonType_e expected_type);
        /// Early step out from JSON scope (you must immediately break the loop/func after step out)
        Exception       (*step_out)(jr_c* it);
    } iter;

    // clang-format on
};

```
